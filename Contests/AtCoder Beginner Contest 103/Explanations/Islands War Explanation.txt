Rather than think of it as a graph, it is much better to think of a straight line with N integer points. 

We are given M segments and must delete the least number of lines so that all the end points of the M segments are disconnected. 

Now, let us consider the end point with the smallest endpoint. Let it be S1 - a1 b1

Now, some line in between a1 and b1 has to be deleted so that it's disconnected. 

However, which line is optimal to delete ? 

Let us delete the last line of the segment a1 b1. 

This ensures the segment a1 b1 is deleted, and also ensures that we can use the same deleted line for next segments.

(If there is any line in the segment [a1, b1] which also occurs in other segments, then it must be the last line of the segment.)

This greedy solution can be seen to be optimal.

So, we sort the segments based on the end points and delete the last edge of a segment only if the segment has no lines already deleted. 
For this, we keep track of the last line to be deleted. 

-----------------------------------------------------------

struct info
{
    int start, end;

    int operator<(info &A)
    {
        return(A.end == end ? start < A.start : end < A.end);
    }
};

int main()
{
    int no_of_vertices, no_of_segments;
    scanf("%d %d", &no_of_vertices, &no_of_segments);

    vector <info> segments(no_of_segments + 1);
    for(int i = 1; i <= no_of_segments; i++)
        scanf("%d %d", &segments[i].start, &segments[i].end);

    sort(all(segments));

    int no_of_deleted_bridges = 0, last_deleted = 0;
    for(int i = 1; i <= no_of_segments; i++)
    {
        if(segments[i].start > last_deleted)
        {
            last_deleted = segments[i].end - 1;
            no_of_deleted_bridges++;
        }
    }

    printf("%d\n", no_of_deleted_bridges);
    return 0;
}